<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cube Alg Visualizer v2.0</title>

<style>
  :root{
    --bg:#ffffff; --text:#000000;
    --tile-bg:#ffffff; --tile-border:#dddddd;
    --stroke:#000000;

    /* outlines follow stroke (works in dark mode too) */
    --outline: var(--stroke);

    /* ...your existing vars... */
  --tileBorderW: 1px;     /* single tiles default */
  --groupBorderW: 3.5px;  /* connected default */
  }

  body.dark{
    --bg:#0f1115; --text:#e9eef7;
    --tile-bg:#151923; --tile-border:#2a3142;
    --stroke:#e9eef7;

    --outline: var(--stroke);
  }

  body{
    font-family:system-ui,sans-serif;
    padding:20px;
    background:var(--bg);
    color:var(--text);
  }

  textarea{
    width: 1040px;
    height: 120px;
    background:var(--tile-bg);
    color:var(--text);
    border:1px solid var(--tile-border);
    border-radius:10px;
    padding:10px;
    resize:none;
    overflow-y:auto;
  }

  .controls{
    display:flex;
    gap:18px;
    align-items:center;
    margin-top:10px;
    flex-wrap:wrap;
  }

  button{
    background:var(--tile-bg);
    color:var(--text);
    border:1px solid var(--tile-border);
    border-radius:10px;
    padding:8px 12px;
    cursor:pointer;
  }

  label{
    user-select:none;
    display:flex;
    gap:8px;
    align-items:center;
    white-space:nowrap;
  }

  /* IMPORTANT: keep as grid or everything goes vertical */
  #out{
    --gapY: 20px;
    --gapX: 30px;

    position:relative;
    display:grid;
    gap: var(--gapY) var(--gapX);
    margin-top:20px;
    align-items:start;
  }

  .tile{
    display:flex;
    flex-direction:column;
    align-items:center;

    position:relative;
    z-index:1;
  }

  svg{
  border: var(--tileBorderW) solid var(--outline);
  border-radius:10px;
  background:var(--tile-bg);
  }

  /* tiles inside bracket groups lose their own border */
  .tile.no-border svg{
    border:none;
  }

  /* group outline segments (one per row-span) */
  .group-span{
    position:relative;
    z-index:3;           /* draw on top so the top edge is visible */
    pointer-events:none;

    height: 90px;        /* TILE */
    align-self:start;
    justify-self:stretch;
  }

  .group-span::before{
  content:"";
  position:absolute;
  inset:0;
  border: var(--groupBorderW) solid var(--outline);
  border-radius:10px;
  }

  /* If the bracket group continues to the next line, don't draw the "end cap" */
.group-span.no-right::before{
  border-right: none;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

/* If the bracket group is continuing from the previous line, don't draw the "start cap" */
.group-span.no-left::before{
  border-left: none;
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
</style>

<link rel="icon" type="image/png" href="https://solvethecube.com/img/logo.png">

</head>

<body>

<textarea id="alg">(R R' R2) L L' L2 (U U' U2) D D' D2 (F F' F2) B B' B2 (r r' r2) l l' l2 (u u' u2) d d' d2 (f f' f2) b b' b2 (Rw Rw' Rw2) (Dw Dw' Dw2) (Fw Fw' Fw2) (Bw Bw' Bw2) (M M' M2) (E E' E2) (S S' S2) x x' (y y') z z'</textarea>

<div class="controls">
  <button id="clearBtn">Clear</button>

  <label>
    <input type="checkbox" id="showLabels" checked />
    Show notation
  </label>

  <label>
    <input type="checkbox" id="darkMode" />
    Dark mode
  </label>

  <label>
    Max Columns:
    <input type="number" id="maxCols" min="1" style="width:70px;">
  </label>

  <label>
    Max Rows:
    <input type="number" id="maxRows" min="1" style="width:70px;">
  </label>

  <label>
    Spacing:
    <select id="gapPreset">
      <option value="20,30" selected>Default</option>
      <option value="0,0">Side-by-Side</option>
      <option value="3,4.5">Extra Tight</option>
      <option value="10,15">Tight</option>
      <option value="16,24">Medium</option>
      <option value="26,40">Loose</option>
      <option value="40,60">Extra loose</option>
    </select>

  <label>
   Single border:
   <select id="tileBorderSize"></select>
  </label>

  <label>
   Connected border:
   <select id="groupBorderSize"></select>
  </label>

   </label>
</div>

<div id="out"></div>

<script>
const ns = "http://www.w3.org/2000/svg";

const TILE = 90;
const PAD  = 8;
const GRID = TILE - PAD*2;
const CELL = GRID / 3;

// Curved radii for wide Fw/Bw
const ARC_R_NORMAL     = 26;
const ARC_R_WIDE_OUTER = ARC_R_NORMAL + 2;
const ARC_R_WIDE_INNER = ARC_R_NORMAL * 0.75;

/* ---------- helpers ---------- */
function el(tag, attrs={}){
  const e = document.createElementNS(ns, tag);
  for (const [k,v] of Object.entries(attrs)) e.setAttribute(k, v);
  return e;
}

/*
  Bracket grouping:
  - Anything inside (), [], {} becomes ONE "group"
  - Nested brackets treated as same group (depth>0)
  - Brackets can be attached to tokens like [(R' or R2)]
*/
function parseAlg(str){
  const tokens = str.trim().split(/\s+/).filter(Boolean);

  const result = [];
  let group = null;
  let depth = 0;

  for (let tok of tokens) {
    const openMatch = tok.match(/^[\(\[\{]+/);
    if (openMatch) {
      depth += openMatch[0].length;
      tok = tok.replace(/^[\(\[\{]+/, "");
      if (depth > 0 && !group) group = [];
    }

    const closeMatch = tok.match(/[\)\]\}]+$/);
    let closes = 0;
    if (closeMatch) {
      closes = closeMatch[0].length;
      tok = tok.replace(/[\)\]\}]+$/, "");
    }

    if (tok) {
      if (depth > 0) group.push(tok);
      else result.push({ type:"single", move: tok });
    }

    if (closes) {
      depth = Math.max(0, depth - closes);
      if (depth === 0 && group && group.length) {
        result.push({ type:"group", moves: group });
        group = null;
      } else if (depth === 0) {
        group = null;
      }
    }
  }

  // unclosed brackets safety
  if (group && group.length) group.forEach(m => result.push({ type:"single", move: m }));

  return result;
}

function parseMove(tokRaw){
  const tok = tokRaw.trim();
  if (!tok) return null;

  const c0 = tok[0];
  const baseUpper = c0.toUpperCase();

  const isPrime  = tok.includes("'");
  const isDouble = tok.includes("2");

  // Wide moves: lowercase or "w" suffix for R L U D F B
  let isWide = false;
  const second = tok[1] || "";
  if ("RLUDFB".includes(baseUpper)) {
    if (c0 === c0.toLowerCase()) isWide = true;        // r u f b ...
    if (second.toLowerCase() === "w") isWide = true;   // Rw Fw ...
  }

  // No wide variants for slices/rotations
  if (["M","E","S","X","Y","Z"].includes(baseUpper)) isWide = false;

  let dir = null;

  // Face turns
  if (baseUpper === "R") dir = isPrime ? "down" : "up";
  if (baseUpper === "L") dir = isPrime ? "up"   : "down";
  if (baseUpper === "U") dir = isPrime ? "right": "left";
  if (baseUpper === "D") dir = isPrime ? "left" : "right";
  if (baseUpper === "F") dir = isPrime ? "ccw"  : "cw";
  if (baseUpper === "B") dir = isPrime ? "cw"   : "ccw";

  // Slices
  if (baseUpper === "M") dir = isPrime ? "up" : "down";      // like L
  if (baseUpper === "E") dir = isPrime ? "left" : "right";   // like D
  if (baseUpper === "S") dir = isPrime ? "ccw" : "cw";       // like F

  // Rotations
  if (baseUpper === "X") dir = isPrime ? "down" : "up";      // like R
  if (baseUpper === "Y") dir = isPrime ? "right": "left";    // like U
  if (baseUpper === "Z") dir = isPrime ? "ccw" : "cw";       // like F
  return { tok, baseUpper, dir, isPrime, isDouble, isWide };
}

function notationString(ins){
  let s;

  // Wide moves display as lowercase face letter
  if (ins.isWide && "RLUDFB".includes(ins.baseUpper)) s = ins.baseUpper.toLowerCase();
  else s = ins.baseUpper;

  if (ins.isPrime)  s += "'";
  if (ins.isDouble) s += "2";

  return s;
}

/* ---------- grid (optionally remove inner verticals ONLY in middle row) ---------- */
function drawGrid(svg, hideMiddleRowInnerVerticals=false){
  for (let i=0;i<=3;i++){
    const x = PAD + i*CELL;
    const isInner = (i === 1 || i === 2);

    if (hideMiddleRowInnerVerticals && isInner){
      // top segment
      svg.appendChild(el("line",{
        x1:x, y1:PAD,
        x2:x, y2:PAD + CELL,
        stroke:"var(--stroke)",
        "stroke-width":"2"
      }));
      // bottom segment
      svg.appendChild(el("line",{
        x1:x, y1:PAD + 2*CELL,
        x2:x, y2:PAD + 3*CELL,
        stroke:"var(--stroke)",
        "stroke-width":"2"
      }));
    } else {
      // full line
      svg.appendChild(el("line",{
        x1:x, y1:PAD,
        x2:x, y2:PAD + GRID,
        stroke:"var(--stroke)",
        "stroke-width":"2"
      }));
    }
  }

  // horizontals always
  for (let i=0;i<=3;i++){
    svg.appendChild(el("line",{
      x1:PAD, y1:PAD + i*CELL,
      x2:PAD + GRID, y2:PAD + i*CELL,
      stroke:"var(--stroke)",
      "stroke-width":"2"
    }));
  }
}

/* ---------- arrow markers (scaled) ---------- */
function ensureArrowMarkers(svg){
  let defs = svg.querySelector("defs");
  if (!defs) { defs = el("defs"); svg.appendChild(defs); }

  function addMarker(id, scale){
    if (svg.querySelector("#" + id)) return;

    const w = 4 * scale;
    const h = 4 * scale;

    const marker = el("marker",{
      id,
      markerWidth: String(w),
      markerHeight: String(h),
      refX: String(2.85 * scale),
      refY: String(2 * scale),
      orient: "90",
      markerUnits: "strokeWidth"
    });

    marker.appendChild(el("path",{
      d: `M 0 0 L ${w} ${h/2} L 0 ${h} z`,
      fill: "var(--stroke)"
    }));

    defs.appendChild(marker);
  }

  addMarker("arrowHeadSmall", 1);
  addMarker("arrowHeadWide",  ARC_R_WIDE_OUTER / ARC_R_NORMAL);
  addMarker("arrowHeadInner", ARC_R_WIDE_INNER / ARC_R_NORMAL);
}

/* ---------- straight arrows ---------- */
function drawStraightArrow(svg, dir, cx, cy, len=24){
  const g = el("g",{ transform:`translate(${cx},${cy})` });
  svg.appendChild(g);

  const line = el("line",{
    stroke:"var(--stroke)",
    "stroke-width":"3",
    "stroke-linecap":"round"
  });

  const head = el("polygon",{ fill:"var(--stroke)" });

  if(dir==="up"){
    line.setAttribute("x1",0); line.setAttribute("y1", len);
    line.setAttribute("x2",0); line.setAttribute("y2",-len);
    head.setAttribute("points", `0,${-len-8} -5,${-len+4} 5,${-len+4}`);
  }
  if(dir==="down"){
    line.setAttribute("x1",0); line.setAttribute("y1",-len);
    line.setAttribute("x2",0); line.setAttribute("y2", len);
    head.setAttribute("points", `0,${len+8} -5,${len-4} 5,${len-4}`);
  }
  if(dir==="left"){
    line.setAttribute("x1", len); line.setAttribute("y1",0);
    line.setAttribute("x2",-len); line.setAttribute("y2",0);
    head.setAttribute("points", `${-len-8},0 ${-len+4},-5 ${-len+4},5`);
  }
  if(dir==="right"){
    line.setAttribute("x1",-len); line.setAttribute("y1",0);
    line.setAttribute("x2", len); line.setAttribute("y2",0);
    head.setAttribute("points", `${len+8},0 ${len-4},-5 ${len-4},5`);
  }

  g.appendChild(line);
  g.appendChild(head);
}

function drawStraightArrowGap(svg, dir, cx, cy, len=24, gap=20){
  const g = el("g",{ transform:`translate(${cx},${cy})` });
  svg.appendChild(g);

  const head = el("polygon",{ fill:"var(--stroke)" });
  const a = gap / 2;

  function addLine(x1,y1,x2,y2){
    g.appendChild(el("line",{
      x1, y1, x2, y2,
      stroke:"var(--stroke)",
      "stroke-width":"3",
      "stroke-linecap":"round"
    }));
  }

  if(dir==="up"){
    addLine(0,  len, 0,  a);
    addLine(0, -a,   0, -len);
    head.setAttribute("points", `0,${-len-8} -5,${-len+4} 5,${-len+4}`);
  }
  if(dir==="down"){
    addLine(0, -len, 0, -a);
    addLine(0,  a,   0,  len);
    head.setAttribute("points", `0,${len+8} -5,${len-4} 5,${len-4}`);
  }
  if(dir==="left"){
    addLine( len, 0,  a,  0);
    addLine(-a,   0, -len,0);
    head.setAttribute("points", `${-len-8},0 ${-len+4},-5 ${-len+4},5`);
  }
  if(dir==="right"){
    addLine(-len,0, -a,  0);
    addLine( a,  0,  len,0);
    head.setAttribute("points", `${len+8},0 ${len-4},-5 ${len-4},5`);
  }

  g.appendChild(head);
}

/* ---------- curved arcs ---------- */
function arcPath(dir, cx, cy, r){
  const off = 6 * (r / ARC_R_NORMAL);
  if (dir === "cw")  return `M ${cx-r} ${cy-off} A ${r} ${r} 0 0 1 ${cx+r} ${cy+off}`;
  return              `M ${cx+r} ${cy-off} A ${r} ${r} 0 0 0 ${cx-r} ${cy+off}`;
}

function drawCurvedMove(svg, dir, r=ARC_R_NORMAL, markerId="arrowHeadSmall"){
  ensureArrowMarkers(svg);

  const cx = PAD + GRID/2;
  const cy = PAD + GRID/2;

  svg.appendChild(el("path",{
    d: arcPath(dir, cx, cy, r),
    fill:"none",
    stroke:"var(--stroke)",
    "stroke-width":"3",
    "stroke-linecap":"round",
    "marker-end":`url(#${markerId})`
  }));
}

function drawCurvedWide(svg, dir){
  drawCurvedMove(svg, dir, ARC_R_WIDE_OUTER, "arrowHeadWide");
  drawCurvedMove(svg, dir, ARC_R_WIDE_INNER, "arrowHeadInner");
}

function drawCurvedTriple(svg, dir){
  const rOuter  = 36;  // bigger outer arc
  const rMiddle = 24;  // middle arc
  const rInner  = 12;  // small inner arc

  drawCurvedMove(svg, dir, rOuter,  "arrowHeadWide");
  drawCurvedMove(svg, dir, rMiddle, "arrowHeadSmall");
  drawCurvedMove(svg, dir, rInner,  "arrowHeadInner");
}

/* ---------- notation text ---------- */
function drawCenterText(svg, textStr, position="center"){
  let x = PAD + GRID/2;
  let y = PAD + GRID/2 + 7;

  if(position === "left")  x -= CELL;
  if(position === "right") x += CELL;
  if(position === "up")    y -= CELL;
  if(position === "down")  y += CELL;

  const t = el("text",{
    x, y,
    "text-anchor":"middle",
    "font-size":"18",
    "font-weight":"700",
    fill:"var(--stroke)"
  });

  t.textContent = textStr;
  svg.appendChild(t);
}

/* ---------- cube rotations arrows ---------- */
function drawXRotation(svg, dir, cutMiddle=false){
  const xLeft  = PAD + 0.5*CELL;
  const xMid   = PAD + 1.5*CELL;
  const xRight = PAD + 2.5*CELL;
  const yMid   = PAD + 1.5*CELL;

  drawStraightArrow(svg, dir, xLeft,  yMid);
  if (cutMiddle) drawStraightArrowGap(svg, dir, xMid, yMid, 24, 25);
  else          drawStraightArrow(svg, dir, xMid, yMid);
  drawStraightArrow(svg, dir, xRight, yMid);
}

function drawYRotation(svg, dir, cutMiddle=false){
  const xMid = PAD + 1.5*CELL;
  const yTop = PAD + 0.5*CELL;
  const yMid = PAD + 1.5*CELL;
  const yBot = PAD + 2.5*CELL;

  drawStraightArrow(svg, dir, xMid, yTop);
  if (cutMiddle) drawStraightArrowGap(svg, dir, xMid, yMid, 24, 26);
  else          drawStraightArrow(svg, dir, xMid, yMid);
  drawStraightArrow(svg, dir, xMid, yBot);
}

/* ---------- layout rule ---------- */
function chooseColumns(n){
  const maxColsInput = document.getElementById("maxCols").value;
  const maxRowsInput = document.getElementById("maxRows").value;

  const maxCols = maxColsInput ? parseInt(maxColsInput, 10) : null;
  const maxRows = maxRowsInput ? parseInt(maxRowsInput, 10) : null;

  // If user provided limits
  if (maxCols || maxRows) {
    let cols = maxCols || 1;

    while (cols <= n) {
      const rows = Math.ceil(n / cols);
      if (maxRows && rows > maxRows) {
        cols++;
        continue;
      }
      return cols;
    }

    return Math.max(1, n);
  }

  // Default behavior (your +2 rule)
  let cols = 3;
  while (cols < n) {
    const rows = Math.ceil(n / cols);
    if (rows <= cols + 2) break;
    cols++;
  }
  return Math.max(1, cols);
}

/* ---------- render tile ---------- */
function renderTile(tokRaw, showLabel){
  const ins = parseMove(tokRaw);
  if (!ins || !ins.dir) return null;

  const wrapper = document.createElement("div");
  wrapper.className = "tile";

  const svg = el("svg",{ width:TILE, height:TILE, viewBox:`0 0 ${TILE} ${TILE}` });

  const note = notationString(ins);

  // remove middle-row inner verticals ONLY when label length is 3
  const hideMiddleRowInnerVerticals = (note.length === 3);
  drawGrid(svg, hideMiddleRowInnerVerticals);

  const xLeft  = PAD + 0.5*CELL;
  const xMid   = PAD + 1.5*CELL;
  const xRight = PAD + 2.5*CELL;

  const yTop   = PAD + 0.5*CELL;
  const yMid   = PAD + 1.5*CELL;
  const yBot   = PAD + 2.5*CELL;

  // R/L/U/D normal + wide (two arrows)
  if(ins.baseUpper==="R"){ drawStraightArrow(svg, ins.dir, xRight, yMid); if(ins.isWide) drawStraightArrow(svg, ins.dir, xMid, yMid); }
  if(ins.baseUpper==="L"){ drawStraightArrow(svg, ins.dir, xLeft,  yMid); if(ins.isWide) drawStraightArrow(svg, ins.dir, xMid, yMid); }
  if(ins.baseUpper==="U"){ drawStraightArrow(svg, ins.dir, xMid,   yTop); if(ins.isWide) drawStraightArrow(svg, ins.dir, xMid, yMid); }
  if(ins.baseUpper==="D"){ drawStraightArrow(svg, ins.dir, xMid,   yBot); if(ins.isWide) drawStraightArrow(svg, ins.dir, xMid, yMid); }

  // M/E (no wide)
  if(ins.baseUpper==="M"){ drawStraightArrow(svg, ins.dir, xMid, yMid); }
  if(ins.baseUpper==="E"){ drawStraightArrow(svg, ins.dir, xMid, yMid); }

  // F/B (wide uses bigger+inner arc)
  if(ins.baseUpper==="F"){ ins.isWide ? drawCurvedWide(svg, ins.dir) : drawCurvedMove(svg, ins.dir); }
  if(ins.baseUpper==="B"){ ins.isWide ? drawCurvedWide(svg, ins.dir) : drawCurvedMove(svg, ins.dir); }

  // S (no wide)
  if(ins.baseUpper==="S"){ drawCurvedMove(svg, ins.dir); }

  // x/y/z rotations
  if(ins.baseUpper==="X"){ drawXRotation(svg, ins.dir, showLabel); }
  if(ins.baseUpper==="Y"){ drawYRotation(svg, ins.dir, showLabel); }
  if(ins.baseUpper==="Z"){ drawCurvedTriple(svg, ins.dir); }

  // notation text inside tile
  if (showLabel) {
    let pos = "center";

    // avoid overlap on these
    if (ins.baseUpper === "M") pos = "right";
    if (ins.baseUpper === "E") pos = "up";

    // x/y/z label should be centered
    if (ins.baseUpper === "X") pos = "center";
    if (ins.baseUpper === "Y") pos = "center";
    if (ins.baseUpper === "Z") pos = "center";

    // wide R/L/U/D: avoid middle arrow
    if (ins.isWide && "RLUD".includes(ins.baseUpper)) {
      if (ins.baseUpper === "R") pos = "left";
      if (ins.baseUpper === "L") pos = "right";
      if (ins.baseUpper === "U") pos = "down";
      if (ins.baseUpper === "D") pos = "up";
    }

    drawCenterText(svg, note, pos);
  }

  wrapper.appendChild(svg);
  return wrapper;
}

/* ---------- render algorithm (with bracket outlines) ---------- */
function renderAlg(){
  const out = document.getElementById("out");
  const showLabel = document.getElementById("showLabels").checked;

  const parsed = parseAlg(document.getElementById("alg").value);

  // Flatten moves, preserve group membership
  const flat = [];
  let gid = 0;

  parsed.forEach(item => {
    if (item.type === "single") {
      flat.push({ move: item.move, groupId: null });
    } else {
      gid++;
      item.moves.forEach(m => flat.push({ move: m, groupId: gid }));
    }
  });

  let cols = chooseColumns(flat.length);
  cols = Math.max(1, Number(cols) || 1);

  out.style.gridTemplateColumns = `repeat(${cols}, max-content)`;
  out.innerHTML = "";

  // group ranges
  const groupRanges = new Map();
  flat.forEach((it, i) => {
    if (it.groupId == null) return;
    const r = groupRanges.get(it.groupId);
    if (!r) groupRanges.set(it.groupId, { start:i, end:i });
    else r.end = i;
  });

  // Add group spans FIRST (they don't affect layout; z-index draws on top)
  for (const [, range] of groupRanges.entries()) {
    const start = range.start;
    const end   = range.end;

    const startRow = Math.floor(start / cols) + 1;
    const endRow   = Math.floor(end   / cols) + 1;

    for (let row = startRow; row <= endRow; row++) {
      const rowStartIndex = (row - 1) * cols;
      const rowEndIndex   = rowStartIndex + (cols - 1);

      const segStartIndex = Math.max(start, rowStartIndex);
      const segEndIndex   = Math.min(end, rowEndIndex);

      const segStartCol = (segStartIndex % cols) + 1;
      const segEndCol   = (segEndIndex   % cols) + 1;

      const span = document.createElement("div");
      span.className = "group-span";
      span.style.gridRow = String(row);
      span.style.gridColumn = `${segStartCol} / ${segEndCol + 1}`;

      // If this row-segment is NOT the final segment of the whole group, remove the right border cap
      const isLastSegmentOfGroup = (segEndIndex === end);
       if (!isLastSegmentOfGroup) span.classList.add("no-right");

      // If this row-segment is NOT the first segment of the whole group, remove the left border cap
      const isFirstSegmentOfGroup = (segStartIndex === start);
      if (!isFirstSegmentOfGroup) span.classList.add("no-left");

out.appendChild(span);
    }
  }

  // Add tiles
  flat.forEach((it, i) => {
    const tile = renderTile(it.move, showLabel);
    if (!tile) return;

    const row = Math.floor(i / cols) + 1;
    const col = (i % cols) + 1;

    tile.style.gridRow = String(row);
    tile.style.gridColumn = String(col);

    if (it.groupId != null) tile.classList.add("no-border");

    out.appendChild(tile);
  });
}

/* ---------- Border size menues ---------- */
function setupBorderDropdowns(){
  const tileSel = document.getElementById("tileBorderSize");
  const groupSel = document.getElementById("groupBorderSize");
  const root = document.documentElement;

  function buildOptions(select, defaultValue){
    select.innerHTML = "";

    // Default option
    const def = document.createElement("option");
    def.value = "default";
    def.textContent = "Default";
    select.appendChild(def);

    // 1px â†’ 5px
    for (let v = 1; v <= 5; v++){
      const opt = document.createElement("option");
      opt.value = String(v);
      opt.textContent = v + "px";
      if (v === defaultValue) opt.selected = true;
      select.appendChild(opt);
    }
  }

  buildOptions(tileSel, 1);
  buildOptions(groupSel, 3);

  function apply(){
    // SINGLE tiles
    if (tileSel.value === "default")
      root.style.setProperty("--tileBorderW", "1px");
    else
      root.style.setProperty("--tileBorderW", tileSel.value + "px");

    // CONNECTED groups
    if (groupSel.value === "default")
      root.style.setProperty("--groupBorderW", "3.5px");
    else
      root.style.setProperty("--groupBorderW", groupSel.value + "px");

    renderAlg();
  }

  tileSel.addEventListener("change", apply);
  groupSel.addEventListener("change", apply);

  apply();
}

/* ---------- events ---------- */
document.getElementById("showLabels").addEventListener("change", renderAlg);
document.getElementById("alg").addEventListener("input", renderAlg);

document.getElementById("maxCols").addEventListener("input", renderAlg);
document.getElementById("maxRows").addEventListener("input", renderAlg);

document.getElementById("darkMode").addEventListener("change", (e) => {
  document.body.classList.toggle("dark", e.target.checked);
  renderAlg();
});

document.getElementById("clearBtn").addEventListener("click", () => {
  document.getElementById("alg").value = "";
  renderAlg();
});

document.getElementById("gapPreset").addEventListener("change", (e) => {
  const [gy, gx] = e.target.value.split(",").map(Number);
  const out = document.getElementById("out");
  out.style.setProperty("--gapY", gy + "px");
  out.style.setProperty("--gapX", gx + "px");
  renderAlg();
});

// apply dark mode on load
document.body.classList.toggle("dark", document.getElementById("darkMode").checked);

setupBorderDropdowns();
renderAlg();
</script>

</body>
</html>